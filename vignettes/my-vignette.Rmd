---
title: "Single Cell RNAseq "
author: "Chenling Xu Antelope"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Vignettes are long form documentation commonly included in packages. 

### load requred packages and pre-computed simulations and data-matched parameters
```{r, fig.show='hold',message=F,cache=F}
homedir <- '/Users/chenlingantelope/ResearchProjects/scRNA_simulation/'
setwd(homedir)
required_packages <- c('devtools','FNN','reshape','ggplot2','gridExtra','ape','MASS','Rtsne','RColorBrewer','fAsianOptions','fOptions','fBasics','timeSeries','timeDate','Biobase' )
install_packages <- rownames(installed.packages())
need_install <- setdiff(required_packages,install_packages)
if(length(need_install)>0){install.packages(need_install)}

load_result <- lapply(required_packages, require, character.only = TRUE)

load('allsim.20170706.robj')
load('match_params.robj')
```
### load package SCsim and set up plotting size in jupyter
```{r,message=F}
setwd('/Users/chenlingantelope/ResearchProjects/scRNA_simulation')
load_all('SCsimR/')
ngenes=100
ncells=100
nevf=10
randseed=0
```

# Overview
The input parameters of the package allow users to control intrinsic variation, technical variation and biological variation in the data. Intrinsic variation is modeled through the kinetic model; technical variation takes into account dropouts, batch effects, GC and length biases of genes; and biological variation is modeled by EVFs (extrinsic variation factors). 

**sim1Pop1Batch** is the main function in the SCsim package. It takes all of the parameters needed for generating the count matrix for a homogeneous population that is sequenced in 1 batch.

 The input parameters are listed below while being categorized by the level of variation they contribute to:

Parameters that affect intrinsic variation:
* **bimod** the proportion of distance to move a point in the kon-koff space towards the center of the kon-koff space where the gene expression is bimodal

Parameters that affect technical variation:
* **alpha** library prep capture efficiency, or dropout of transcript: the number of of captured transcript is distributed as the number of successes with probability of success alpha in X trials, where X is the true number of transcripts
* **alpha_sd** the standard deviation of alpha (to add noise for different efficiency for each cell)
* **nbins** the number of bins for gc and length bias
* **gcbias** the magnitude of gc bias (a number between 0 and 2) 
* **lenbias** the magnitude of length bias (a number between 0 and 2)
* **batch_mean** The mean batch effect from which the batch effect of each gene is sampled from
* **batch_sd** The standard deviation of batch effect from which the batch effect of each gene is sampled from
* **noise** the standard deviation of a normal distribution where the log(noise) is sampled from
* **randseed** the random seed to generate the gc and length bins (should keep constant for each experiment regardless of the batch and population, but should change for replicates of simulations)

Parameters that affect biological variation:
* **evf_mean** a vector of length nevf, the means of the normal distribution to sample EVF from 
* **evf_sd** a vector of length nevf, the standard deviation of the normal distribution to sample EVF from
* **gene_effects** a matrix of ngenes * nevf, generated by GeneEffects function

Other parameters: 
* **ncells** number of cells to simulate


# Prepare input parameters: Compute gene effects 
The gene effect is a matrix of ngenes*nevf, generated by GeneEffects function and remains the same across all experiments. Its role is explained in the **evf** section of this document
```{r,cache=T}
gene_effects <- GeneEffects(ngenes=ngenes,nevf=10,randseed=0,sd=1,prob=0.3)
```

# Simulation: an example run 
We will simulate a dataset using the sim1Pop1Batch and visualize the results with function PlotCountHeatmap. The output of the sim1Pop1Batch function is a list of sampled EVF for each cell, and transcript count matrices that have different levels of noise added to it. In the follwing example, temp is the output of the funcion. temp[[1]] is a list of **evf** for each cell, temp[[2]] is the true transcript counts directly sampled from the stationary distribution given expression dynamic parameters, temp[[3]] is after dropout, and temp[[4]] is the dropped out counts plus batch effects and gene-specific biases.

```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
temp<-sim1Pop1Batch(evf_mean=rep(1,nevf), evf_sd=rep(0.2,nevf),ncells=ncells,
        randseed=0,gene_effects=gene_effects,bimod=0.1,alpha=0.1,
        alpha_sd=0.01,nbins=10,gcbias=0.1,lenbias=0.1,batch=exp(rnorm(ngenes,0,0.1)),noise=0.1,
        matched_params=match_params1)
log_count_bins<-seq(0,4,0.4)
knitr::kable(head(do.call(rbind,temp[[1]]), 2))
par(mfrow = c(1,3))
ord1<-PlotCountHeatmap(LogDist(temp[[2]],log_count_bins),rowMeans(temp[[2]]),NA,1,paste('truecounts.bimod=',bimod,'.jpeg',sep=''))
ord2<-PlotCountHeatmap(LogDist(temp[[3]],log_count_bins),rowMeans(temp[[3]]),NA,1,paste('droppedcounts.bimod=',bimod,'.jpeg',sep=''))
ord3<-PlotCountHeatmap(LogDist(temp[[4]],log_count_bins),rowMeans(temp[[4]]),NA,1,paste('biasedcounts.bimod=',bimod,'.jpeg',sep=''))
gridExtra::grid.arrange(ord1,ord2,ord3,ncol=3)
```


# Test the effect of parameters on changing various levels of variation

## The intrinsic variation from the stochastic nature of gene expression
We use a kinetic gene expression model that assumes that a gene switches between an 'on' state and an 'off' state. The rate of turning on is $k_{on}$ and the rate of turning off is $k_{off}$. Transcripts are synthesized at rate $s$ when the gene is on. They also degrade at rate $d$ regardless of the state. From these four parameters we can calculate the stationary distribution of the abundance of each transcript in each cell. The first variation that we simulate is this intrinsic variation, which means that even when expression is governed by exactly the same parameters (or as we will refer to it, the cells sharing the same parameters are in the same population), cells might have different transcript counts. The amount of variation can be tuned by changing the parameter range. 

We give each gene in the same population the same $k_{on}$, $k_{off}$, $s$ and $d$ ($d$ is always 1) with some noise added for each cell. We noticed that the expression distribution tend to be bimodal, and has high variation when $k_{on}$ and $k_{off}$ are very small, as shown on the heatmap below. The first plot shows how the fano factor increases at the bottom left corner when $s=10$. To increase the intrinsic variation we can vary the bimod, or $\beta$ parameter so that the $k_{on}$ and $k_{off}$ parameter is closer to the bottom left corner within the region of bimodal distribution (purple clolor in the second plot, where the value 2 indicates that the distribution has 2 inflection points). Note that the axis are on log scale. 

```{r,fig.height = 2.5, fig.width = 6.5, fig.align = "center",cache=T}
setwd(homedir)
source('SCsimR/MasterEqnLookup.funcs.R')
load('SCsimR/Simulation_DistFeatures.20170706.robj')
dist_features<-dist_features[dist_features[,3]==10,]
fano_plot <- MasterEqn_heatmap(Fano,dist_features,'20170706.MasterEqn_Fano_Heatmap.pdf','Fano Factor','log')
mean_plot <- MasterEqn_heatmap(Diptest,dist_features,'20170706.MasterEqn_Diptest_Heatmap.pdf','number of inflections','identity')
grid.arrange(fano_plot,mean_plot,ncol=2)
```

### The effect of changing beta on parameter distribution
The paramete bimod, or $\beta$ can be set to a value from 0 to 1. 0 means that we keep the original $k_{on}$ and $k_{off}$. Any value above 0 means that we move the original $k_{on}$ and $k_{off}$ closer to the center of bimodality ($k_{on}=-1$ and $k_{off}=-0.5$) by $\beta$ the distance between the center and the original point. When $beta$ is set to 1, then all of the $k_{on}$ and $k_{off}$ have value $-1,-0.5$. You could experiment with the effect of $\beta$ by chaning the value of bimod in the next cell and see the distribution of $k_{on}$, $k_{off}$ and $s$ for different values of $\beta$

```{r,fig.height = 4, fig.width = 4, fig.align = "center",cache=T,message=F}
bimod <-0.8
evf_mean<-rep(0,10)
evf_sd<-rep(0.1,10)
evfs <- lapply(c(1:ncells),function(celli){
	evf <- sapply(c(1:length(evf_mean)),function(evfi){rnorm(1,evf_mean[evfi],evf_sd[evfi])})
	return(evf)
})

params<-lapply(c(1:ncells),function(i){Get_params(gene_effects,evfs[[i]],match_params1,bimod)})
param1<-do.call(rbind,lapply(params,function(X){X[1,]}))
p<-PlotParamHist(param1,paste('beta=',bimod,'.1',sep=''))
grid.arrange(p)
```

### The effect of changing beta on gene expression distributions
After sampling the kinetic parameters for each gene, we can now simulate the gene expression matrix with the bimodality parameter, using the function sim1Pop1Batch. There are many other parameters in the function that we will introduce later. We can visualize the expression matrix using a 2D histogram with the function PlotCountHeatmap.  

We can visualize the expression matrix using a 2D histogram with the function PlotCountHeatmap.  

```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
bimod <-0.9
temp<-sim1Pop1Batch(evf_mean=rep(1,nevf), evf_sd=rep(0.2,nevf),ncells=ncells,
        randseed=randseed,gene_effects=gene_effects,bimod=bimod,alpha=0.1,
        alpha_sd=0.01,nbins=10,gcbias=0.1,lenbias=0.1,batch=exp(rnorm(ngenes,0,0.1)),noise=0.1,
        matched_params=match_params1)
log_count_bins<-seq(0,4,0.4)
ord1<-PlotCountHeatmap(LogDist(temp[[2]],log_count_bins),rowMeans(temp[[2]]),NA,1,paste('truecounts.bimod=',bimod,'.jpeg',sep=''))
ord2<-PlotCountHeatmap(LogDist(temp[[3]],log_count_bins),rowMeans(temp[[3]]),NA,1,paste('droppedcounts.bimod=',bimod,'.jpeg',sep=''))
ord3<-PlotCountHeatmap(LogDist(temp[[4]],log_count_bins),rowMeans(temp[[4]]),NA,1,paste('biasedcounts.bimod=',bimod,'.jpeg',sep=''))
gridExtra::grid.arrange(ord1,ord2,ord3,ncol=3)
```

### The effect of changing beta on gene expression fano factor 
To do a more systematic comparision we will perform simulations with 10 different $\beta$ values. 
And compare the fano factor of gene expression when bimod increases. We see that as we artificially increase the amount of bimodality the fano factor increases. 
```{r,fig.height = 2, fig.width = 4, fig.align = "center",cache=T}
change_bimod <- lapply(seq(0,1,0.1),function(bimod){
    start <- proc.time()
	temp<-sim1Pop1Batch(evf_mean=rep(1,nevf), evf_sd=rep(0.1,nevf),ncells=ncells,
			randseed=randseed,gene_effects=gene_effects,bimod=bimod,alpha=0.1,
			alpha_sd=0.01,nbins=10,gcbias=0.1,lenbias=0.1,batch=exp(rnorm(ngenes,0,0.3)),noise=0.1,
			matched_params=match_params1)
    #print(proc.time()-start)
	return(temp)
})
fano_compare <- lapply(change_bimod,function(X){apply((X[[2]]),1,function(Y){var(Y)/mean(Y)})})
fano_compare <- do.call(rbind,fano_compare)
rownames(fano_compare)<-seq(0,1,0.1)
df<-melt(fano_compare)
colnames(df)=c('beta','rep','exprs_fano')
p <- ggplot(df, aes(x=factor(beta), y=exprs_fano))
p <- p + geom_boxplot()+ scale_y_continuous(trans='log10')
p
```

## The technical variation #1: dropout (cell specific)

After obtaining the true count matrix, we need to simulate the dropout process where not all of the transcripts are presented in the library. For a simple approximation we model the number of transcripts from a gene in a library as a binomial sampling process, where the number of trials is the number of transcripts of the same gene, and each transcript has probability $\alpha$ of being sampled. 
To make the simulation more realistic, the $\alpha$ parameter is not the same for every cell, but is sampled from a normal distribution centered at $\alpha$, with standard deviation $alpha_sd$. The final distribution is truncated at 0 and 1 because probability must be between 0 & 1. 
The following plot shows the expression matrix before and after $\alpha=0.1$ was added. 

```{r,fig.height = 2.5, fig.width = 6, fig.align = "center",cache=T}
gridExtra::grid.arrange(ord1,ord2,ncol=2)
```

### The effect of $\alpha$ on the mean and fano factor of the gene expressions. 
```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
change_alpha <- lapply(seq(0,1,0.1),function(alpha){
    TrueCounts2Dropped(temp[[2]],alpha,alpha_sd=0.1)
})
mean_compare <- lapply(change_alpha,function(X){rowMeans(X)})
mean_compare <- do.call(rbind,mean_compare)
rownames(mean_compare)<-seq(0,1,0.1)
df<-melt(mean_compare)
colnames(df)=c('alpha','rep','exprs_fano')
p <- ggplot(df, aes(x=factor(alpha), y=exprs_fano))
p1 <- p + geom_boxplot()+ scale_y_continuous(trans='log10')
fano_compare <- lapply(change_alpha,function(X){apply((X),1,function(Y){var(Y)/mean(Y)})})
fano_compare <- do.call(rbind,fano_compare)
rownames(fano_compare)<-seq(0,1,0.1)
df<-melt(fano_compare)
colnames(df)=c('alpha','rep','exprs_fano')
p <- ggplot(df, aes(x=factor(alpha), y=exprs_fano))
p2 <- p + geom_boxplot()+ scale_y_continuous(trans='log10')
grid.arrange(p1,p2,ncol=2)
```
# Technical variation #2 $\lambda$: batch effects, GC and length bias, noise (gene and batch specific)
We model the bias and batch effect by multiplying the dropped count matrix by four vectors of length number of genes.
* gc bias(all genes in the same gc bin is multipled by a factor according to their bin. Higher gc content is biased towards higher expression) 
* length bias (all genes in the same length bin is multipled by a factor according to their bin. Longer genes are biased towards lower expression)  
* batch (noise that is sampled for each gene but is the same for all cells in the same batch)
* jiggle (simple noise that is sampled for every gene in every cell independently)


**notes**: genes are randomly assigned to a length or gc bin: but as long as the parameter randseed and number of genes do not change, the same genes are assigned to the same bins everytime. So in practice the trends of gc and length bin do not matter. 
### gc and length bias


```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
gcslope <-0.1;lenslope<-(0.1);nbins=10
gcslope <- gcslope/nbins; lenslope <- lenslope/nbins
gc_bias <- c(1:nbins)*gcslope
gc_bias<-(gc_bias+(1-median(gc_bias)))[c(1:nbins)]
len_bias <- (-c(1:nbins))*lenslope
len_bias<-(len_bias+(1-median(len_bias)))[c(1:nbins)]
par(mfrow=c(1,4))
plot(gc_bias)
plot(len_bias)
batch <-0.5
batch <- exp(rnorm(ngenes,mean=0,sd=batch))
hist(batch,20)
batch <-0.5
batch <- exp(rnorm(ngenes,mean=0,sd=batch))
hist(batch,20)
```

**The code to generate the new count matrix with the dropped count matrix is the following**
```R
biased_exprs <- apply(dropped_exprs,2,function(X){
    jiggle <- rnorm(length(X),mean=0,sd=epsilon)
    Y <- X * gc_bias * len_bias * batch * exp(jiggle)
    return(Y)
})
```

The comparison of the dropped count matrix and the biased count matrix could be visualized using the count heatmap. 
```{r,fig.height = 2.5, fig.width = 6, fig.align = "center",cache=T}
gridExtra::grid.arrange(ord2,ord3,ncol=2)
```

# Extrinsic Variation $\sigma$
We use a cell specific vector that we term **evf**, or extrinsic variation factor to model the cellular state or environmental factors that affect the kinetic parameters of gene expression. It has length $nevf$. Each element in the **evf** vector is sampled independently. Each kinetic parameter for each gene has its own $gene\_effect$ vector of length $nevf$. Its value is determined by a function $f$ of the dot product $x_{i,j} = evf_i * gene\_effect_j$. The role of the function $f$ is to transform the dot product $x$ to the correct paramter range and give a distribution of parameter that is close to the experimentally fitted distribution of the kinetic paramters. 

## Sampling evf

**evf** is sampled from a normal distribution of mean $evf\_mean$ and standard deviation $\sigma$. The cells in the same population share the same $evf\_mean$ but will have more similar sampled **evf** is sigma is small. We can explore the effect of sigma on the distribution of $k_{on}$, $k_{off}$ and $s$ for a random gene by looking at the histogram distribution of $k_{on}$, $k_{off}$ and $s$ after altering the **Sigma** value in the following code block. 

```{r,fig.height = 4, fig.width = 4, fig.align = "center",cache=T,message=F}
Sigma<-0.2
evf_mean<-rep(0,10)
evf_sd<-rep(Sigma,10)
evfs <- lapply(c(1:ncells),function(celli){
	evf <- sapply(c(1:length(evf_mean)),function(evfi){rnorm(1,evf_mean[evfi],evf_sd[evfi])})
	return(evf)
})
params<-lapply(c(1:ncells),function(i){Get_params(gene_effects,evfs[[i]],match_params1,0)})
param1<-do.call(rbind,lapply(params,function(X){X[1,]}))
p<-PlotParamHist(param1,'temp')
grid.arrange(p)
```
Similarly, we can explore effect of sigma on the distribution of gene expression for all genes in a homogeneous population by visualizing the gene expression heatmap

The three plots correspond to 
* true counts
* sampled counts (sampled binomially with probability $\alpha$)
* biased counts (sampled binomially with probability $\alpha$, and added the gene and batch specific bias term $\lambda$)

```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
Sigma<-0.2
#start <- proc.time()
temp<-sim1Pop1Batch(evf_mean=rep(1,nevf), evf_sd=rep(Sigma,nevf),ncells=ncells,
    randseed=randseed,gene_effects=gene_effects,bimod=0,alpha=0.1,
    alpha_sd=0.01,nbins=10,gcbias=0.5,lenbias=0.3,batch=exp(rnorm(ngenes,0,0.3)),noise=0.1,
    matched_params=match_params1)
#print(proc.time()-start)
log_count_bins<-seq(0,4,0.4)
ord1<-PlotCountHeatmap(LogDist(temp[[2]],log_count_bins),rowMeans(temp[[2]]),NA,0.9,paste('truecounts.sigma=',Sigma,'.jpeg'))
ord2<-PlotCountHeatmap(LogDist(temp[[3]],log_count_bins),rowMeans(temp[[3]]),NA,0.9,paste('droppedcounts.sigma=',Sigma,'.jpeg'))
ord3<-PlotCountHeatmap(LogDist(temp[[4]],log_count_bins),rowMeans(temp[[4]]),NA,0.9,paste('biasedcounts.sigma=',Sigma,'.jpeg'))
gridExtra::grid.arrange(ord1,ord2,ord3,ncol=3)
```
We can simulate populations of cells of different **Sigma** values and look at how sigma affects the fano factor and mean expression by the box plot where y axis is the expression fano factor on log scale, and x axis is the sigma value used. We expect the mean to be unaffected and the fano factor to increase as we increase the **Sigma** value

```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
change_sigma <- lapply(seq(0.1,1,0.1),function(Sigma){
    #start <- proc.time()
	temp<-sim1Pop1Batch(evf_mean=rep(1,nevf), evf_sd=rep(Sigma,nevf),ncells=ncells,
			randseed=randseed,gene_effects=gene_effects,bimod=0,alpha=0.1,
			alpha_sd=0.01,nbins=10,gcbias=0.5,lenbias=0.3,batch=exp(rnorm(ngenes,0,0.3)),noise=0.1,
			matched_params=match_params1)
    #print(proc.time()-start)
	return(temp)
})
fano_compare <- lapply(change_sigma,function(X){apply((X[[2]]),1,function(Y){var(Y)/mean(Y)})})
fano_compare <- do.call(rbind,fano_compare)
rownames(fano_compare)<-seq(0.1,1,0.1)
df<-melt(fano_compare)
colnames(df)=c('sigma','rep','exprs_fano')
p <- ggplot(df, aes(x=factor(sigma), y=exprs_fano))
p1 <- p + geom_boxplot()+ scale_y_continuous(trans='log10')

mean_compare <- lapply(change_sigma,function(X){apply((X[[2]]),1,function(Y){mean(Y)})})
mean_compare <- do.call(rbind,mean_compare)
rownames(mean_compare)<-seq(0.1,1,0.1)
df<-melt(mean_compare)
colnames(df)=c('sigma','rep','exprs_fano')
p <- ggplot(df, aes(x=factor(sigma), y=exprs_fano))
p2 <- p + geom_boxplot()+ scale_y_continuous(trans='log10')
grid.arrange(p1,p2,ncol=2)
```
# Simulating evf from multiple discrete populations
We model discrete populations that are related to each other in a tree structure. We first randomly generate a tree, assume that each discrete population is sampled from the leave of the tree. Thus their *evf_mean* should be related to each other by a variance-covariance matrix corresponding to distances between leave nodes. We first visualize the topology of the tree and the variance-covariance matrix that correspond to the distances in the tree
We can then sample **evf_mean** from a multivariate normal distribution centered around 0 with the variance-covariance matrix obtained from the tree, and visualize if given the number of evfs and the tree structure, the experimental variance-covariance matrix of the **evf_mean** still is similar to the theoretical one.

```{r,fig.height = 2.5, fig.width = 8, fig.align = "center",cache=T}
phyla<-rcoal(5)
plot(phyla)
cor_evf_mean<-vcv.phylo(phyla,cor=T)
varplot<-melt(cor_evf_mean)
varplot$V1<- factor( varplot$X1, levels = phyla$tip.label[order(cor_evf_mean[,1])])
varplot$V2<- factor( varplot$X2, levels = phyla$tip.label[order(cor_evf_mean[1,])])
p1 <- ggplot(data=varplot,aes(x=V1, y=V2, fill=value)) + geom_tile() + theme_bw()
pop_evf_mean<-mvrnorm(nevf,rep(0,5),cor_evf_mean)
cor_evf_mean_exp <- cor(pop_evf_mean)
varplot<-melt(cor_evf_mean_exp)
varplot$V1<- factor( varplot$X1, levels = phyla$tip.label[order(cor_evf_mean[,1])])
varplot$V2<- factor( varplot$X2, levels = phyla$tip.label[order(cor_evf_mean[1,])])
p2 <- ggplot(data=varplot,aes(x=V1, y=V2, fill=value)) + geom_tile() + theme_bw()
grid.arrange(p1,p2,ncol=2)
```
**Npop1Batch** is a wrapper around the function **sim1Pop1Batch**  that generate **evf_mean** according to the input tree structure. It then samples **evf** vectors for each cell and then use the **sim1Pop1Batch** to generate data sampled from multiple populations but within the same  batch$\lambda$. 

The parameters for **Npop1Batch** is only different from the **sim1Pop1Batch** by 
* it takes a tree as an input and generate $evf\_mean$, instead of a constant for the $evf\_mean$
* the ncells parameter is a vector of length npop.

It returns a list of 2 elements: all_counts and meta. all_counts is a list of 3 matrices of nrow=number of genes and ncol=sum of number of cells in each population. The fist matrix is the real counts, the second matrix is the counts after dropout, and the third matrix is the biased counts. each row of meta correspond to 1 cell in the count matrix, and the most important information in it is the 'pop' column that tells which population a cell comes from
```{r}
result <- Npop1Batch(phyla=phyla,nevf=10,
	evf_sd=0.1, ncells=rep(50,5),
	randseed=0,gene_effects=gene_effects,bimod=0,alpha=0.1,
	alpha_sd=0.05,nbins=10,gcbias=0.1,lenbias=0.1,batch=0.1, noise=0.1)
knitr::kable(head(result[[2]]))
```

# Recovering structure from transcript count matrix from different populations of cells
First we try to use tSNE to see if the resulting transcript count matrix refelcts the tree structure using the function **PlotTsne**, which takes 5 inputs:
* meta: the meta data from Npop1Batch
* data: a transcript count matrix
* label: one of the column names in meta, determines what the datapoints would be colored by
* saving & plotname: if saving==T then save the plot to a jpeg file with filename=plotname, otherwise plot in console. 
It returns the result of tSNE clustering of Rtsne

The following cell shows the tSNE results plotted using 
* true counts
* sampled counts (sampled binomially with probability $\alpha$)
* biased counts (sampled binomially with probability $\alpha$, and added the gene and batch specific bias term $\lambda$)
```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
tsne1 <- PlotTsne(meta=result[[2]],data=result[[1]][[1]],label='pop',plotname='')
tsne2 <- PlotTsne(meta=result[[2]],data=result[[1]][[2]],label='pop',plotname='')
tsne3 <- PlotTsne(meta=result[[2]],data=result[[1]][[3]],label='pop',plotname='')
gridExtra::grid.arrange(tsne1[[2]],tsne2[[2]],tsne3[[2]],ncol=3)
```

We use another dimensionality reduction method PCA, which should preserve longer distance relationship better than tSNE. The input and outputs of PlotPCA is the same as PlotTsne, and uses *prcomp* instead of *RTsne*

```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
pca1 <- PlotPCA(meta=result[[2]],data=result[[1]][[1]],label='pop',plotname='')
pca2 <- PlotPCA(meta=result[[2]],data=result[[1]][[2]],label='pop',plotname='')
pca3 <- PlotPCA(meta=result[[2]],data=result[[1]][[3]],label='pop',plotname='')
gridExtra::grid.arrange(pca1[[2]],pca2[[2]],pca3[[2]],ncol=3)
```

# Simulate multiple batches but with multiple populations
**NpopNBatch** is another wrapper around the main function **sim1Pop1Batch**, where the batch specific parameter $\lambda$ is allowed to be different between batches. $\alpha$ can also vary between batches. This can be used to test if technical biases could affect the result of clustering. We expect the true count matrix and the dropped count matrix to not be affected by batch effect, and if the batch effect is large enough, for the biased count matrix to cluster by both population and batch. 
```{r}
result2 <- NpopNBatch(phyla,nevf=10,nbatches=3,
	evf_sd=0.1,ncells=matrix(rep(10,15),nrow=3),
	randsee=0,gene_effects=gene_effects,bimod=0,alpha=rep(0.1,3),
	alpha_sd=rep(0.01,3),nbins=10,gcbias=c(0.5,1,1.5),lenbias=c(0.5,1,1.5),
	batch=c(0.5,0.5,0.5),noise=rep(0.1,3),same_evf_mean=T)
```

### plot tSNE coloring by populations
```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
tsne1 <- PlotTsne(meta=result2[[2]],data=result2[[1]][[1]],label='pop',plotname='')
tsne2 <- PlotTsne(meta=result2[[2]],data=result2[[1]][[2]],label='pop',plotname='')
tsne3 <- PlotTsne(meta=result2[[2]],data=result2[[1]][[3]],label='pop',plotname='')
gridExtra::grid.arrange(tsne1[[2]],tsne2[[2]],tsne3[[2]],ncol=3)
```

### plot tSNE and color by batch
```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
tsne1 <- PlotTsne(meta=result2[[2]],data=result2[[1]][[1]],label='batch',plotname='')
tsne2 <- PlotTsne(meta=result2[[2]],data=result2[[1]][[2]],label='batch',plotname='')
tsne3 <- PlotTsne(meta=result2[[2]],data=result2[[1]][[3]],label='batch',plotname='')
gridExtra::grid.arrange(tsne1[[2]],tsne2[[2]],tsne3[[2]],ncol=3)
```

### plot PCA coloring by population identity
```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
pca1 <- PlotPCA(meta=result2[[2]],data=result2[[1]][[1]],label='pop',plotname='')
pca2 <- PlotPCA(meta=result2[[2]],data=result2[[1]][[2]],label='pop',plotname='')
pca3 <- PlotPCA(meta=result2[[2]],data=result2[[1]][[3]],label='pop',plotname='')
gridExtra::grid.arrange(pca1[[2]],pca2[[2]],pca3[[2]],ncol=3)
```

### Plot PCA coloring by batch
```{r,fig.height = 2.5, fig.width = 9, fig.align = "center",cache=T}
pca1 <- PlotPCA(meta=result2[[2]],data=result2[[1]][[1]],label='batch',plotname='')
pca2 <- PlotPCA(meta=result2[[2]],data=result2[[1]][[2]],label='batch',plotname='')
pca3 <- PlotPCA(meta=result2[[2]],data=result2[[1]][[3]],label='batch',plotname='')
gridExtra::grid.arrange(pca1[[2]],pca2[[2]],pca3[[2]],ncol=3)
```


